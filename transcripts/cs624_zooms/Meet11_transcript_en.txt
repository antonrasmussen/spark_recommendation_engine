Hello everyone. We'll get started in a couple of minutes. Sam. Yes. So, yeah, so we will be trying to do some of the last session today. Just give me a minute, Sam. Okay. I will be uploading some of these slides which I'm discussing today after our class. Again, today is our last class and this is the end of the semester. >> Speaker 2: I just wanted to go over a. >> Speaker 1: Very important concept, generally very common. It's been common across my different classes. Now, something that is very popular, NoSQL. I talked about it in my database class, Data science class. And definitely it's very much relevant to the big data class. So we will end our class today with this topic, NoSQL. And before doing that I would just go over the syllabus ones. All right. If anybody has any questions. All right. So you know, so this was our deliverables. Assignment 1, Assignment 2, Assignment 3 pretty much has been graded and if you have not received a grade, just send me an email. Things could be that you might have not presented or either you don't have not submitted a file. So please check that with me as soon as possible. Your project one is also graded. Project two is something where you are working on. It's a recommendation engine, so you're working on that. Your M class should have been graded. If any of your labs have not been graded, just let me know. Lab is still ongoing. I discussed this last week. So most of your deliverance are. We are in a state where it's absolutely clear and you're almost right, you might have already submitted everything. But if you have any pending grades, something is not, you know, you have concerns. This is the time because we are wrapping up the course. So just let me know if you have anything. All right then, regarding the syllabus. So I just want to quickly go over what we did in this course. We started with Intro to Big Data. What is Big Data? What is a big Beta ecosystem. We started with understanding what is Hadoop, what is Spark, why Spark is more famous than Hadoop. What are the different components of Spark? What are the different APIs? What is Spark? SQL? What is Spark? SQL transformation, Spark. So we spent some good amount of time understanding Spark and we had a lot of built in code that was given to you with a lot of data through the labs. And then we entered into Spark Machine Learning. And in the end last class we went on to some of the performance issues that generally big data or maybe big database frameworks such as Spark has. And we also discovered these two topics. Recommendation Engine one, which you are already developing A project on using SPARK and the other was the Generative AI. A very brief topic. Why Generative AI is important. But I hope this course was useful to you and if you in the future, if you need any additional material, any resources, not just to this class, but if you like my. Any other courses or you want more material, just let me know. And if possible I would like to. I would be very much willing to share that with you now. Yes. Okay. Yeah. So. So if students if you have any questions regarding assignments, please send me an email. It's much easier for me because I'm taking a class here. So I will respond to your email. Yeah. Okay. So as I said, today is our last class. It's just going to be lightweight and we will be wrapping it up. We'll be completing our course today. I want to end the course with this topic called NoSQL again I will upload the slides after the class tonight and it should be accessible to you for downloading. NoSQL database are currently a hot topic, right? In some parts of computing with hundreds of different NoSQL databases. Now, if you have worked with relational database management systems earlier. RDBMS data is stored in columns and tables. Generally whenever we talk about relational databases it's MySQL and where the data is stored in columns tables. The relationships are represented by data most and relationships means. Basically means like tables where tables could be employee, right? It could be employee table. It could be something department table employee related to department relationships are represented by data. And then you have data manipulation language. You have data definition language, right? These are. So data manipulation is like writing update statements, delete statements basically are trying to manipulate the data. And in data definition language you are. >> Speaker 2: Going to create. >> Speaker 1: Database objects. It could be table stored procedures, views, right? And then we have transactions. This is there's something called as in relational databases you have transaction transactions are very familiar. We have a total slide on that next which we'll discuss. It gives us some asset properties. And basically whenever you try to have some queries run as a unit, either they run completely or that they run. They do not. They do not save at all, right? You have requirements such as. Then you go with transactions databases. Relational databases also gives us abstraction from physical layer which basically means that whenever you have queries that are executing, we don't really worry about how these queries are internally executing, how they are executing fetching data from databases. This is all abstracted and we work at the surface or the application layer. So RDBMS has very good characteristics that a Lot of today's applications require. One of the main properties of relational databases is transactions is called asset properties and transactions is somewhere we have atomic. All of the work gets completed and gets completed committed or none of it get completed. Consistency. So for example, if you put two transactions, a transaction to transfer from one account to another involve making a withdrawal operation from the first account and a deposit operation on the second. If the deposit operation is failed, you don't want the withdrawal option to happen. So this is a classic use case where two transactions must happen one after other. And if any one of them fails, we need to make sure that both transactions are rolled back. And this type of feature is provided by relational databases using property called as atomic. And then the next property is called consistency. A transaction transforms the data from one consistent state to another consistent state consistency is divided in terms of constraint. See, whenever we are putting data into your database, a lot of times we have columns in our databases and these columns basically. >> Speaker 2: Just give me a minute. >> Speaker 1: Yeah. So we have a lot of rules that you could put like, okay, you don't want a particular column to be not null, you want a particular column value to be greater than 50. These are some things you can put rules on your database columns and therefore you can maintain the consistency of the data in your database. The next one is isol. The results of any changes made during a transaction are not visible until the transaction is committed. Sometime we want multiple transactions to execute in our database, right? But we want to ensure that, for example, this transaction where you are making a withdrawal and then you're making a deposit, we want to ensure that you know, you want to first withdraw and then deposit, right? So to do that you must first withdraw and then you need to deposit and to for that to happen, right? For that to happen, the transaction need to be saved, but it, it cannot be saved completely. It's like soft save. So only when both, both the queries inside a transaction save, save, then only we call it as hard save. But sometimes until everything is completed inside a transaction, whatever queries have been executed till then, you want only a soft swipe. So the complete results of the partially executed queries are not available to the viewer of the database until the complete transaction is completed and that property is called isolated. And then the last property of asset is called T durable, the result of a committed transaction survive failures. See, whenever you put something in a transaction, if one query executes and other query doesn't execute or we know that we can roll it back, that's atomic property. But similarly, if for some reason, the first query executes and the second query fails because of a power issue or something. The database should also provide a mechanism that you are able to survive the failure, right? So that property is called durable. So here the four properties, atomic, consistency and isolation. Durable are the four properties of a transaction that are pretty much useful in your database. Now these two properties, right? This property, RDBMS and transactions, these two properties are basically very much helpful for relational databases. But if we are given so many good properties, why do we need NoSQL? And how is NoSQL different from relational databases? And why are we discussing that in a big data class? I already told you, this is a topic which, it's a small topic which I have discussed in data science class, database class, and here it's relevant to all the data. So if I'm teaching any data class, it's relevant everywhere. So especially I believe that with big data, it's the most relevant topic. NoSQL stands for no relational, no RDBMS, not only SQL. It basically means that, see, in general relational databases you have tables and columns. Here we don't really mean that. NoSQL has nothing to do with tables and columns, right? So that is no relational and then no rdb. It is not related to relational database management systems like MySQL, Ms. SQL Server, Postgres. These are relational management data systems where you have entities, entities could be your business entities like department advisor, doms, and all these entities are connected to each other in some logic, right? And you store the data for them in relational databases such as MySQL Ms. SQL Server. But NoSQL, you don't have to deal with that. And not only SQL. So NoSQL is an umbrella term for all databases and data stores that don't follow the traditional RDBMS principles. So it's a basic class of products or a collection of several concepts. But data storage on manipulation and it's basically related to large data sets. See, whenever we say large data sets, one of the question would be, hey, can't we store 1 million routes in a MySQL database? Yes, you could store in 1 million rows in a MySQL database database. And that will, that's a very, very large data set. But the question is, let me, let me show you something. Give me a minute. So here you can see that the student names and email addresses so you can have a student and student email. This is a traditional MySQL database and you can store some rows and columns. But can you store a complete File in this column. Basically we're storing a string or some decimal. These are traditional values that we can store in a database. But can we store a completely string in a database that's big? How to store something large as that which traditional databases are not built for. If you talk about MySQL there are some columns and data types in MySQL which are called blob and they might be helpful to store documents. But generally relational databases are not built for something so big like storing documents in your columns. Now no SQL definition from a definition point. So you know these are non relational. Basically they have nothing to do with tables, columns and tables being related to each other. They are distributed in fashion. See, whenever you have a lot of SQL, we are executing an Ms. SQL Server or MySQL these are standalone database servers. And whenever you execute something they are executing on the server, right? They are not executing on a distributed system like Apache Spark. When you execute something called a Spark SQL, it's executing a distributed. You know what distributed means? So you know. But, but no, many times there is requirement that you need a framework that executes in a distributed fashion. And your relational databases are not designed to execute in a distributed computing platform. So that's also something driving the need requirement for NoSQL and we need open source systems. Some of your relational databases are Open source like MySQL, but many of them SQL Server, post like Oracle, these are proprietary databases and horizontally scalable. Now for scalability, remember there are two types of scalability. One is called vertical scaling and one is called horizontal scaling. Vertical scaling is something when you add more resources to your existing server. And horizontal scaling is when you clone up the server and open up, spin up multiple, you know, copies of it. So what, why, why do you need, first of all, why do you need scaling, right? So for example, if there is a website, Amazon and it Everyday traffic is 1 million customers on Thanksgiving, let us say the customers increase to 10 million. So it needs to scale up the number of resources the database servers, Web servers need to scale up immediately to, to, to handle the 10 million traffic, right? But once the traffic is done next day after Thanksgiving, 10 million might become again 1 million. So you need scale down. So one thing you could do is you, you can suppose you have one server, big server, Amazon server, you can add more ram, you could add more gb, you could add more hard disk and increase the database, you know, or web server resources in a single server. That is vertical scaling. Horizontal scaling is something you make a copy and you clone it and you distribute the load. So horizontal scaling is pretty much more known option nowadays to load the traffic. So these are again non relational distributed, open source and horizontal scaling are the main reasons for, you know, no SQL motivation. Now the the original intent has been modern web scale databases. And the web scale movement began early 2009 as growing rapidly. See many times when we about why this there's a huge scale, it's because of web, right? So web has Web especially now IoT devices they require special characteristics. They're so huge, the data is so huge that you need to scale up your databases. And traditional database systems won't work for this type of data. For example, just for example. See sometime you have like some Fitbit data, right? So Fitbit data could what it could have, it could customer. It could have heart rate, distance, number of steps. So this might be for coming from a customer and this could be coming for one minute, right? The Fitbit device might send more data in the next minute, next minute, next minute and so on. So the data is getting increased. So you might have around, you know, 60 to 24, you know, 1440 records per day for one customer. What if you had 1 million customers, right? So your table size will increase and increase and explode. And you know one thing that is common is when your table size increases, your read and write efficiency decreases, right? Your input output on the table decreases. So any queries that is running on your Fitbit table would become very, very slow. So to handle such amount of massive data, right? Especially this is called time series data, you have new databases, something called as time series databases, but you have other databases also called as NoSQL databases which do not. This is which handle data that your traditional or conventional databases cannot handle. So that's the advantage of your NoSQL motivation. Just okay, where does NoSQL come from? No, non relational databases are not new, but NoSQL represent a new incarnation due to massively scalable Internet of things based on distributed and parallel computing, right? So development starts with Google and a lot of you can read some of these papers which has led to to the development OR Rise and NoSQL. One thing that is very famous today also is Dynamo. Dynamo is a key value database store. You will see that quickly what it means. So NoSQL is very much popular with big data and NoSQL comes from Internet that is often related to as big data concept. Now how much big are we talking about? Or few terabytes enough to start spanning multiple storage units. Now what is the challenge with big data? The Whole class, we have been discussing why big data is so important, right? So one of the reasons is that efficiently we need to store access large amount of data is difficult. Even more considering fault tolerance and backups. So remember what is fault tolerance and backup? Fault tolerance is something if you have everything we are running on a cluster when we talk about big data frameworks and if one of the nodes the results should be recalculated automatically without impacting the complete result. So that is fault tolerance. And data should be always backed up so that if something fails, data could be retrieved. So these are challenges generally in big data and manipulating large data center modeling immensely parallel processes, also challenging. Managing continuously evolving schema and metadata for semi structured and structured data is difficult. See a lot of times see, suppose you have a traditional column, right? In traditional databases your data is structured. So you have rows. You have basically some rows and columns, right? You have column names, right? But tomorrow see, I have student name, student emails, advisor name, advisor email. But tomorrow if I want to add one more, two columns, right? For some reason, department name, department email and then I want to delete department name. If I keep doing that, there will lot of operational challenges with maintaining such evolving schema. You can add data but then you drop columns, then your data might get corrupted. So it's extremely challenging to maintain the evolving schema. But many times see, if you're designing data for a university, right? Database of a university, your tables such as department, advisor, student, they don't change over time. They're pretty much the same, right? Nothing is going to change. But many times outside, right? The requirements are different. For example, I'm a website, I'm taking some forum survey or something, data from the users. Today I Decide there are two columns, tomorrow I decide there are 10 columns. Then I decide, no, no, I don't want only three columns. So it's completely different. It's based on Dynamics Market survey, right? So my data requirements might keep changing, but I don't want a fixed schema. I want to take all the data and dump it somewhere. I don't want to worry about the table columns. I just want all the data as a document or some file where I can save the file. But that is not where the traditional databases are built. That's one of the challenge we have and that's why NoSQL is becoming popular now. How did we get here? There are multiple reasons. Explosion of the social media sites with large data needs. Rise of cloud based solutions such as Amazon S3, right? And just as moving to dynamically typed Languages. So technology has been a key enabler of also getting NoSQL here. So one of the key concepts here is Amazon S3, right? If you have not known what is Amazon S3, I think I've explained it before. But Amazon S3 is a storage layer. So we know what is a Hadoop file system. Hadoop file system is where you can store all type of files you have worked on with different kind of files in your assignment. 1 parquet file CSV file similarly here in Amazon S3 it's like a bucket data store where you could put any, any kind of data. And remember you could put just, you know, structured data, semi structured data, unstructured data, it doesn't matter, you can put any type of Data, then Amazon S3 will hold it. So the demand for large data. >> Speaker 2: The. >> Speaker 1: Emergence of storage layers technology and supporting programming languages have helped NoSQL to rise. >> Speaker 2: In today's database ecosystem. >> Speaker 1: Now why are RDMs not suitable for big data? The context is Internet RDMs assume the data are dense and largely uniform structured data. But that's not the case. We know that a lot of data is not structured. Your tweets, logs, these are all unstructured data. So where will we go and store it? We need a system to store that. So your structured data is only some part of it where you are storing it. But most of other things like semi structured data, CSV, you know, something like your JSON file, XML file, you don't store it in your rdbms. Right. So that's, that's the problem. So data from come coming from Internet is massive and sparse, semi structured or unstructured. Right. I was telling about web service, the data could be semi structured on structure. You want to store tweets, what is the length of a tweet? I mean it's fixed sometimes in Twitter, but whatever other social media platforms. So it's, it's, you don't have a limit and then how would you store it in a relational database? It's going to be difficult. Now with massive sparse data set, the typical storage mechanisms and access method get stretched. And that's why RD are not suitable for big data. So NoSQL, the distinguished characteristic are large data volumes, Google's big data. So most importantly I would say is these two things here. The queries need to return answer quickly. So when you're talking about NoSQL, we need queries very fast. And the second one is mostly query few updates. So see you're not updating schema. A lot of times you are just Querying the data more right inserting or retrieving the data. So it's a very distinguishing characteristic when compared to relational databases. Now till now, from here to here, right? We were Discussing what is NoSQL, what is relational databases? MySQL Ms. SQL, what are the characteristics? One of the main properties of relational databases were transactions, right? Then we discussed about how did we start, how did we start using NoSQL? What is the NoSQL definition? We discussed about what are the distinct characteristics. Now let's go to the interesting part where we want to see what is this NoSQL database actually means. Top three things here is something called as document databases. I've been telling that in NoSQL you could store documents directly. In some key value store you could store keys and values in your databases and in graph databases you could store, you know, graphs. It would from a slide point you would see that it's not that interesting. Hey, do we really care about. But I will show you something interesting and why this is so, so so such a hot area. The first one, let's focus on document databases, right? So documents like loosely structured sets of key value pairs like xml, JSON, they encapsulate and data in some standard formats or encoding and you want to save the whole document. Documents are treated as a whole, avoiding splitting the document to its constitution name value pairs. We want to save the whole database. And are there any databases for storing these XML or JSON files? If you have heard, MongoDB is one database which is very, very, very popular. So nowadays if you're Even applying for AI, they might ask you that you do MongoDB and it's like bunch of queries. You get used to it. It's not maybe a couple of weeks and you will get started. So don't lose this skill set. No SQL, you just need to know a couple of syntax and how to insert, update, delete data in MongoDB and you're all set. So just don't worry about the keyword much and I don't know this and lose a job opportunity because you don't know you're hearing it for the first time. It's easy to work with these things. >> Speaker 2: Now. >> Speaker 1: The main advantage here, documents are schema free. Different documents can have different structure schema that differ from one another. See, when we're talking about MySQL we have a table structure you have for suppose advisor column, you have the faculty name, faculty email address that's there column and it's a fixed schema. But what if in your table. Or you want to store different schema. >> Speaker 2: You want to have different documents, they have different schema inside. How would you do that? >> Speaker 1: Right, so with, with MongoDB and. >> Speaker 2: No, no, something called the document databases, you could, you could have, you could, you could store different JSON files or you could store different XML files which have different schema. Now we need to still understand how these XML file and JSON file look like. And I will go through that briefly after I finish this slide deck. That will give us understanding of what semi structured data looks like. So generally when we talk about JSON files, it's all key value pairs. This is a JSON object from here to here, and there's also a JSON object from here to here. It has some attributes and some values, right? And this is all a object. And here you have attributes and some values, right? So this is all you can say. Now you want to save this whole document, you know, from here to here. You want to save it in a column. How do you save it in traditional databases? You won't be able to save it, right? I mean, there is options. You could, you could save. MySQL has. Certainly you could, but you don't have the efficiency and the speed that NoSQL databases such as MongoDB will give you because it is built from scratch to handle this Data. Whereas in MySQL it's just an option, it's an additional feature they are giving you. But it's not built to do that. It's built to handle relational data. Whereas MongoDB is built to handle these kind of data. That's document data. Then we have the key value stores. Now key value stores, many times you have keys and you have some values, you want to store that and you just want to store this so that you can rapidly, very fast pull this information when needed. For example, key could be a deal id, right? So you can have thousand deals sitting in some memory location and when Amazon page lands, it's retrieving all the data from the server. And instead of going into a database, see, whenever you hit the database, the query is hitting a database. The input output, right, will be very high, so there will be more latency. What if you don't retrieve the data from the database but you retrieve the data from the memory? Right. A lot of times there are, there are no SQL databases, something called as Redis, something called as Dynamo. What they do is like they put everything in the memory. The database itself is in the memory. So you are actually hitting the database and Everything is. You send a key and you retrieve the value. It's very fast. It's extremely fast. So just in some nanoseconds you get the result which is very, very fast than if the application would have connected to a regular database. Right? So that's one of the advantages of key value stores. You can, you can Google this Redis, right? I highly encourage you to do so. And if there are any open notebooks, generally go to their website, right? Redis website or Amazon Dynamo. The easiest thing to start with these tools is just go and look at their. Any Google Collab notebooks. There should be available plenty in GitHub. Just. Just take and start working on them. One or two and you will get a feel of it. All you need to do to start is get a feel of it so that you can really understand what is the difference between key value store. What is the difference between document db. Right? So at least you will be able to differentiate different NoSQL databases. Most important thing is NoSQL is not MongoDB. Only somehow people get confused that MongoDB is NoSQL and that's it. No, it's not. There are different type of NOSQLs. One is the document database which is MongoDB. The other one is the key value where, where you store the key values. And the vendor popular vendors are Amazon Dynamo, from Amazon Apache, Cassandra, Redis. So these are popular vendors for this databases, right? And there are some advantages of doing NoSQL. You can take a look into that slide. Now the next one is the graph database. See till now we saw document database, you know, then we saw key value database and then we have the graph database. So in the graph database, you know this particular. This is like a graph. What do you see is like you have set of nodes, edges. They're connected through some of the edges. And it. You can model many problems as graphs. So one of the famous problems is traveling salesman problem. It's. It's basically is to find the shortest path or shortest cost when you know when. Suppose you have many airports and they are all connected as it can be the. The. Your flight ticket purchase could be modeled as a graph problem. Because all nodes are airports and they're connected through distance which is their edges. Then you can put some cost onto it the fair amount. And you want to find the shortest path between A to B with shortest duration and shortest fair, right? So that is a graph problem. And many times whenever you have graph problems you could. You want to predict the next node. So it also becomes. Sometime you Know the, the machine learning problem. So many something called as graph neural networks. If please try to see that it's very becoming, very, very popular graph neural networks. And so you need graphs as your input data for many machine learning models, right? And social media link prediction is a graph problem, right? Your attack graphs attack graph something in cyber security is a graph problem. So many times you have data and you need to take that data, put it as a graph. Once you put it as a graph then you want to do something like predict the next link, something like that. To do that you need to store this data and you need to retrieve this graph data efficiently. If I have data something like this, can I put this data in a table relational database where your columns. No, I can't. Maybe you can adjust it but it's not that much efficient. Right. So you need a separate database to deal with this and that's where the graph databases come in. And I'll try to open one thing here, just give me a minute. So look at this. This is one of the vendors for a graph database called Neo4j and there are many graph databases available. This is one of the top ones and you can go to their website and see but you know it's. It's the most loved graph database as they claim and it helps with lot of real time recommendation engine nowadays generative AI. So by learning NoSQL you are also, I call it as you are also learning databases for AI. So when you are working with traditional databases, it's not the database for AI, but a lot of these databases which you're talking about is the databases for AI. So it's supporting databases. So you're indirectly learning AI technology by learning these, these databases as well now dealing with big data. So these are some popular NoSQL database types and the companies we saw some companies which are actually building these products. Again, let's not all get confused with. Again MongoDB is not NoSQL. MongoDB is one of the vendors for NoSQL document database. Redis, Amazon, Dynamo are for key value pair database types. And then Neo4j is something as a graph database, one of the NoSQL database. So the multiple vendors out there supporting each type of NoSQL database, right there are hundreds of them out there. But these are some even if know the one which I've talked about, MongoDB, Redis, Apache, Cassandra and. And also the one which I was trying to Neo4J there's more than. I mean this is good, very, very good. Start from a skill set Point you should be ready for, for the job market if you have some hands on experience with these, these tools. Now let's go and try to see more on why what is this? You know, if we had to go with traditional, you know, traditional databases, relational databases, what are the issues with it? So issues with scaling up when data set is too big. RDMs were not designed to be distributed. We have been talking about it. Traditional databases are best designed to run well on a single machine, right? No SQL solutions are designed to run on clusters or multi node database solutions. So that's the big, big, big difference. Why NoSQL is very from the framework itself is designed so that it can run on cluster whereas you know, your traditional databases are, you know, they can only on single machine. Now for some reason, some reason you decide that hey, I have a MySQL server, I want to scale it up, you know, I have 1 million customers, tomorrow I might have 10 million customers. I want to scale it up. So what is the scaling opportunities available for traditional relational database systems, right? So one thing is right, see this could be your application, it could be Amazon website to websites out there. And this is your database, right? So you might make a clone of these databases and you know, make one master and slave slave the other one. So this is a distributed architecture, right? But remember, your data is not distributed here. Your data is here, the copy is again here, the copy is again here. So your applications are free to read from any of these things. So to load balance there, right? But one of the problems is if you write something here, it needs to be written here, then it needs to be written here and it's going to be taking time, which is fine. And you have another architecture called as Sharding. This is another way to scale up your machines. But one of the main problems is RDBMs are acid. So whether you are following this architecture or whether you are following this architecture to scale up your relational databases, the problem is you have to deliver atomicity, consistency, isolation and durability. Remember the slide which we were talking about this one. So if you put want to put multiple queries in a single transaction, right? And you want to make sure that transaction executes, you know, it is going to be challenging. This is why traditional databases are famous. But if you want to have that and you want to also scale up, it's going to be difficult because in this type of architecture, right, if you want to give ACID properties, it's not going to scale, it's not going to be easy. So it won't Work properly. So that's the problem. So NoSQL does not give importance to asset problem node, doesn't care about your aspect. That's one of the disadvantages of NoSQL. But that's fine. We are more worried about the scalability. So it's a different framework, different objectives, different properties, different features. One important thing to underline or note here is relational databases are not an alternative to NoSQL and NoSQL is also not an alternative to relational database. I mean, sorry, it's not. Relational databases has their own requirements and they will exist in the coming years. NoSQL has its own requirements and it will exist in the coming years. Each of them is not an alternative. That's something I wanted to discuss about the NoSQL and as I said I will upload the slide deck the after the class. Also let me discuss about this one. Okay, so the many times we in our course we have been discussing about three things, right? What is your big data could be structured data, it could be semi structured data or it could be unstructured data. So let's take a very very quick look of what this unstructured data or you know what the semi structured data means. So because we know what structured data is unstructured data, the logs and text file. But what is semi structured data which sits in between? So in this slide deck we will understand what is a semi structured data model and why is it useful. We learn some of the xml, DTD and JSON syntaxes and something we'll quickly discuss. What is the difference between XML and JSON? Why are they popular? Things like that. Semi structured data does not have a rigid schema. Very important. See the moment we move away from relational databases we're going to NoSQL. We are talking more on the semi structured unstructured data. So we will be leaving the rigidity of schema. We are not focused on fixed columns, fixed data types and because that's a problem with relational databases. So. So semi structure does not have a rigid schema. So it does not conform to a data table or relational database structure. How it has classifying characteristics associated with such as internal semantic types or metadata or marking that enable analysis. So the first type of semi structured data we have is xml, right? So XML is also called as extensible markup language. >> Speaker 1: It's the. >> Speaker 2: The. It's defined by WWT consortium W3C and these are the bodies which define standards. So many times you and standards are always out there, whether it's academics or whether it's industry Right. And the standards are gone by certain body. For example, AI is growing, right. So there must be many attacks on AI. So there is, there are some bodies that are especially something like Nest, they came up with how would you develop AI so that it's secure, trustworthy. Right. It's a governing body. Similarly WWT consortium, W3 schools, not school, sorry WW2 consortium, that's the defining body for XML. So they make sure XML is what is the standard. So generally XML has tags giving extra information about the sections of the document. For example, here you have title, there is always closing and opening and closing tag and some value in between. Right. Important thing to note is XML looks like very much like HTML. >> Speaker 1: Right. >> Speaker 2: So HTML is another markup language. You might may already know about it. And HTML has a lot of tags. These tags have some meaning to it. Basically every tag is something like a object that you can visually see on your browser. So your browser, whether it's Google Chrome, Internet, you know, Internet, Mozilla, they all they understand is HTML and some JavaScript. They're designed to interpret this tags and visually represent them. And some dynamic programming can be done using JavaScript. So mostly HTML is all DAX. So similar to HTML, XML is also tags. But the big difference is HTML is you know, a limited number of tags. Whereas xml, you can extend your tags, you can create your own tags, custom tags. So that's the advantage and many times this becomes a standard. So lot of medical data they could be in XML files because these medical organizations can create their own tax. Similarly if you know about financial filings. So every big, big companies need to file their data and there's financial data, something called a SEC filings, they can file their data as you know these tags because you could put their own tax out there. But still you are following some standards it right. You're not putting something in text. So that's the advantage of xml. Semi structured data. Now one of the key advantages of motivation, right? Why is so. So yes it's semi structured data, but why? Because this became so much important. Why did XML become so much important? So data interchange is critical in today's networked world. Banking, funding orders, order processing, scientific data. See many times there is a requirement that two parties want to exchange data. Right now one party could be built in with one technology. Other party could be built with another technology. For example, one party could be built with dotnet with C Sharp programming language. Now the other software could be built with Java. Now both want to communicate certain data. Java won't understand dotnet.net won't understand Java, so how will they exchange data? So for that reason you could do is you could could say send some data from Java as XML file, serialize as XML file. This could be loaded by a dotnet program and you know, deserialized it basically making the XML data and creating an object into C sharp object in its memory. So this way both programming language, two different programming language can communicate with each other because they have a common data standard. Right? That's why data is very. Data standards are very important and this way XML was becoming very popular because multiple frameworks were able to exchange data with the help of xml. >> Speaker 1: Right? >> Speaker 2: That's the main advantage. Now what is the main advantage of if we compare with structured data? So in tables we have taped columns and rows. Why don't, why don't we just use that? Why, why do you have to use xml See xml what is inefficient, it's all tax, which in effect represents schema information. And sometimes these tags could be repeated. So it's little bit more, you know, not that efficient but, but it's definitely better than you know, your database standards. Why? Because of these things. Unlike relational tuples, XML data is self documenting due to presence of tags. Its non rigid tags can be added, allows nested structures wide acceptance not only in database systems, but also allows in browsers, tools and application. So when this point especially allows nested structures, imagine can you put a table inside a table and then inside a table, right? Multiple tables in a single table, you can't do that in relational databases, right? But when you talk about XML data, you can put tags within tags and you could have lot of hierarchy and nesting which might be required for your data. And you can easily exchange that data with multiple vendors or you know, either it is between different technologies. All that thing becomes extremely easy. The data sharing becomes extremely easy when you have XML and it becomes extremely difficult if you had the data as tables or relations. So the structure of XML data, you have tag, you have elements and elements must be properly nested and every document must have a single top level element. So these are some requirements to have a structure for your XML data. And this is how your XML data looks like. So this could be a bank document. Inside you could have one customer, this could whole thing could be repeated again for another customer. Another customer, right? And inside that you could have attributes and some values. This is all tag and value based mechanism here. So here these are elements can have attributes, e.g. account type = to checking. Attributes are specified by name Value pairs inside the starting tag of an element. An element may have several attributes, but each attribute name can only occur once. So leave some of the dtds and you know, it could be self explanatory here, but I will go through some of the important thing. Let me go here. >> Speaker 1: Okay. >> Speaker 2: I will explain the dom. When I'm explaining XML versus JSON, let me start talking about JSON. So one last thing before we jump to JSON is XML parsing. See, whenever you want to load the XML file and want to see the values within the file, there are some libraries available here. What you basically do is load your xml also called as document object model and then you pass through the document object model, which is basically you will have a root node inside the root node. You have some child node. Each child node might have more child nodes. So some child nodes might be parent nodes, right? You need to keep traversing the document object model or the tree and, and then you basically retrieve the values as based on your requirement. So it's, it's more has you have to deal with parsing. You might want to add some nodes, you want to delete some node, you want to manipulate the data in certain nodes. These are general operations you do in XML data. Similarly, you have a JSON file, right? So in JSON it's called the JavaScript job notation. It's a really language independent, most programming languages can easily read it and instant object or some other data structure. See, JSON was very popular, you know, around 2009, it's still popular and at that time we used to make Ajax calls, which is synchronous calls from the website to push some data or get some data from the remote server, right? And why this was very, very popular for websites was because it's a lightweight alternative. So see, XML is a very, very big document, but JSON is very lightweight. It's just some string key value pairs. So you can take some survey data from user, put it in some strings and send it to push it to a remote server from a website. And when it's lightweight, it's helped with the encryption part deserialization. Also, you know, it's helpful to send it through the network across multiple hops. So it's very, because it's lightweight. So that's the advantage of JSON, right? And as you look here, it's very easy, right? You might take this data from a forum, employee forum on a website, employee ID name, higher date and some values. That's it. This is, and you serialize this data. So it's just key value pairs. Very simple, Very, very simple. So in JSON value must be one of the following data type, a string, a number object, an array. You can have array also here a boolean or null values. So these are some restrictions for your JSON data types. Now one of the advantages of having JSON is look at the XML file right here. So this is your XML file and this is your JSON file. So if you want to send data, you want your somebody is filling a forum website form or somebody is, you know, putting something on their mobile app. You want to send this data to a remote server, you will send a XML file or you will just send this JSON data. Because JSON data as you look, it's extremely lightweight, you don't have to deal with all these tags and because it's almost like a document, right? So that's why lightweight choice is JSON. It's a very, very lightweight to exchange data. Again, let's remember why do we have these two semi structured data types so popular for data interchange, right? Suppose dotnet wants to exchange data with Java. Java don't exchange data with dotnet, right? Or maybe you, you can send it as XML or you can also send it as a JSON file. So data interchange is becoming very, very easy with this semi structured data type. That was the major advantage. And by now you should, you might be already know this is the end of the course. So you might have already worked with JSON data if your data set was JSON. If not then I, I do believe that you know, since you are in this data science or in data big data track anyways you will be dealing with data which would be JSON maybe in your projects or in the future. So, and all you need to do is you have already worked with Pandas so you will be loading data in JSON format and then once you have, you know, you will be, you can put it in the data frame and from there you know what, what to do, right? You have already worked with your assignment to Assignment 3 so you know pandas loading data and how to manipulate data. So parsing data is extremely easy with JSON with current python libraries. So the xml vs JSON JSON is like xml because both JSON xml are self describing, JSON xml are hierarchical and both JSON and xml can be passed and used by a lot of programming languages. But JSON is unlike SQL because JSON doesn't use N tag, JSON is shorter, JSON is quicker to read and write, JSON can use arrays and JSON has a better fit for object oriented systems than xml, so it's definitely a better choice. So the biggest difference is XML has to be parsed with an XML parser. JSON can be parsed by standard JavaScript function. >> Speaker 1: That's another advantage, especially if you're working. >> Speaker 2: On the browsers, you want very lightweight tools. So that's one reason JSON excels in the web area. So in summary, semi structured data does not have the same level of organization and predictability of structured data. But the data does not reside in fixed fields or records, but does contain elements that can separate the data into various hierarchies. This model introduces two examples of semi structured data format, XML and JSON. So please take a deeper look. Again, once I post the slides it will be tonight. So I will post the slides semi structured data and NoSQL. >> Speaker 1: It. >> Speaker 2: Okay, so that was it. Just wanted to discuss the NoSQL and that's the series of our lecture. There may or may not be a additional video that I might post. I will send an announcement once I post the slides. The additional video is from my other class and if I, if I have a recording available, I might post it. I. I don't know it's still been still available or not. But if it's available, I will post that video. It deals with text, some. Some text analytics. So I want that also to be available if, if that has been already recorded. But it's. It's not for sure. But I will try to see and. >> Speaker 1: Get you that as well. >> Speaker 2: I will do an announcement after the class in the night and let me also just go through the syllab. Okay so all due dates are done for the labs Assignment 1. All due dates are done here. So we have done all the assignments here the project. So the only thing that is left now is the August 8th, right four days from now. The building the recommendation engine with Spark and extended in class lab. This should be very easy. If you have any issues, let me know. But this, this is of course we wanted to do a little bit big but I couldn't have the credits so I made it as a report. But, but whatever PDF I have shared, if you have time, I highly recommend, you know, do it your own. Not for the course but ensure that, you know, you don't put your credit card into something where there's a lot of billing. That's one of the problems, you know, you could run into. So be extremely careful. If you're following the PDF and you're actually executing it, your credit card will be built and you don't want to get into problem with a very very huge amount of bill. I. I've gone through that. So. So I don't want you to run into the same issue. The second one here is the building recommendation system. I hope you know you have all the resources with you to do this again. If you have any issues. I told this a couple of times in class. I'm available from 4:30 to 5:25, Monday to Thursday. So the next three days also I'm available. So please come and if you have any issues let me know. And yeah up and hopefully you submit. Everybody submits their projects, you know with the due date because I. I need to finish the grading as the fall is going to start and I would have a deadline to submit your grades. So please submit it by August date if any. For. For any reason you need a extension you need to let me know and for valid reason I might extend it. But please try to to submit it on time. Okay then that's it. It was an honor to teach everyone one of you. I hope you enjoyed the class. And I'm taking couple of classes this semester as well fall one of the trustworthy health analytics. It's online asynchronous class where you deal with health data. If you're interested please take a look into the CS department schedule and yeah hope to see you in my next courses. Yeah. Thank you. And let me know if you have any issues or concerns. Thank you professor. Thank you. Thank you Dr. Nicole. Thank you. Thank you. >> Speaker 1: Thank you. >> Speaker 2: Hey Professor. Yes. It's been an awesome course. I have learned a lot and I appreciate you taking the opportunity and the time to give us individualized attention. Thank you so much James. I enjoyed the class as well. Thank you so much. I'm going to finish up the extended lab and the project number two here this week while I'm out at Cyber Fortress and I'll get it into you by the 8th. I hope to get it in by tomorrow night but if I can't I'll definitely get it in by the 8th. Sure. Awesome. Sounds good. Thank you very much. You have a great evening. You too. Bye. >> Speaker 1: Thank you for the course professor and just want to I'll send you a follow up email but my assignment to miss pending a grade. But that's okay, just take your time whenever you can get to it. That's good. Yep. >> Speaker 2: Absolutely. I hope you sent me an email just so that I can go and take a look at it. But I remember Sam. >> Speaker 1: Right. >> Speaker 2: So I. I'll Just check. >> Speaker 1: Thank you, Professor. >> Speaker 2: No problem. >> Speaker 1: Take care. It. 